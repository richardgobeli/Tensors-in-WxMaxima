/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 26.01.0-DevelopmentSnapshot ] */
/* [wxMaxima: title   start ]
Find the Hagihara frame that defines
an orbit in the Schwarzschild metric 
and in the Gullstrand–Painlevé metric.
   [wxMaxima: title   end   ] */


/* [wxMaxima: section start ]
Setting up
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Find the Hadihara frame that defines orbit in schwarzschild metric.  Setting up")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
if get('ctensor,'version)=false then load(ctensor_r1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
get('ctensor,'version);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
if get('itensor,'version)=false then load(itensor);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
get('itensor,'version);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
imetric(g);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ctrgsimp:true$
cframe_flag:true$
verbose:true$
ratfac:true$
ratchristof:true$
derivabbrev:false$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Use square brackets for matrices
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Use square brackets for matrices")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lmxchar:"["$rmxchar:"]"$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Enter exterior Schwarzschild metric with frames
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Enter exterior Schwarzschild metric with frames")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ct_coordsys(exteriorschwarzschild);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(false);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
assume(c>0);
declare(c,constant);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
facts(c);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Dummy coordinate definition
list:[equations,[coordinates]]    ")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
list:[t,r,theta,phi,[t,r,theta,phi]];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Transform the exteior Schwarzschild coframe to the same coordinates")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri:ctransformfrilist(fri,list);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Setup variable limits in exterior Schwarzschild metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
assume(m>0,r>0);facts(r);facts(m);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(true);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fr;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
christof(mcs);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find velocity of coframe fri in Schwarzschild coordinates.
Fri being similar to diagonal metric square root.
This is a static shell frame.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find velocity of coframe fri in Schwarzschild coordinates.
Fri being similar to diagonal metric square root.
This is a static shell frame.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("set up rest speed uv1 in frame ")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uv1[1]:c$uv1[2]:0$uv1[3]:0$uv1[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uv1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ufv)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("find the speed in schwarzschild coordinates")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iufv:ufv([-μ],[])=uv1([],[a])*frame([a],[μ])$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iufv)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cufv:ic_convert(iufv);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cufv,frame:fr);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Static shell frame 4 velocity in Schwarzschild
coordinates has no spatial components.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Static shell frame 4 velocity in Schwarzschild
coordinates has no spatial components.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ufv[1]:ufv[1],rootscontract$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ufv);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ufvm);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iufvm:ufvm([],[])=g([μ,ν],[])*ufv([],[μ])*ufv([],[ν])$ishow(iufvm)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cufvm:ic_convert(iufvm);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Magnitude is constant -c^2=-1
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Magnitude is constant -c^2=-1")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cufvm);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find the 4 acceleration in the frame.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find the 4 acceleration in the frame using schwarzschild coordinates.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uf[1]:c$uf[2]:0$uf[3]:0$uf[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uf);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iua:ua([-μ],[])=uf([],[λ])*covdiff(uf([],[μ]),λ)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cua:ic_convert(iua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Exterior Schwarzschild frame 4 acceleration
Components are the effective gravity for stationary observer
directed downward.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Exterior Schwarzschild frame 4 acceleration
Components are the effective gravity for stationary observer
directed downward.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Frame metric is lfg gives magnitude squared.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
ua[2]*ua[2]*lfg[2,2];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Magnitude of d^2(r)/dτ^2 as function of r
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
num(sqrt(%))/(sqrt(expand(denom(%)/r^4))*r^2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Find a coframe that is free falling and in a circular 
orbit, which is the Hagihara observers.
Stable orbits would be r > 6*m. 
Unstable orbits 3*m < r < 6*m because of 
angluar momentum and energy.
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Find a coframe that is free falling and in a circular 
orbit, which is the Hagihara observers.
Stable orbits would be r > 6*m. 
Unstable orbits 3*m < r < 6*m because of 
angluar momentum and energy.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
assume(cc>0);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ratfac:true;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
depends([aa,bb,cc,dd],ct_coords);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Put the boost in the phi coordinate
set up the mixed fri coframe.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mfri:zeromatrix(dim,dim)$mfri[1,1]:aa$mfri[1,4]:-bb$mfri[4,1]:-cc$mfri[2,2]:sqrt(r/(r-2*m))$mfri[3,3]:r$mfri[4,4]:dd$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(frii([a,μ],[])=lfgg([a,b],[])*mfrii([μ],[b]))$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri:lfg.mfri;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("calculate the new frame dependant fr.  
    It shows the boost in phi coordinate.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
frr:ratsimp(transpose(invert(ufg.fri)));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Start with this coframe and it should get Schwarzschild metric back.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Start with this coframe and it should get Schwarzschild metric back.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Get the metric from this coframe
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Get the metric from this coframe")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lgg:transpose(lfg . fri) . fri,ratsimp;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Equate to the exterior Schwarzschild metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Equate to the exterior Schwarzschild metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq1:lgg[1,4]=lg[1,4];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq2:lgg[4,4]=lg[4,4];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq3:lgg[1,1]=lg[1,1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("solve for aa,bb,dd")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sol:solve([eq1,eq2,eq3],[aa,bb,dd]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("use solution 1 where aa,bb,dd are positive")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
saa1:sol[1][1];sbb1:sol[1][2];sdd1:sol[1][3];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Substitute back in and there is still one unknown cc(r)
Solve for 4 acceleration to be zero to get cc(r).
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Substitute back in and there is still one unknown cc(r)
Solve for 4 acceleration to be zero to get cc(r).")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mfri:zeromatrix(dim,dim)$mfri[1,1]:rhs(saa1)$mfri[1,4]:-rhs(sbb1)$mfri[4,1]:-cc$mfri[2,2]:sqrt(lg[2,2])$mfri[3,3]:r$mfri[4,4]:rhs(sdd1)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri:lfg.mfri;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Equation for metric from coframe.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Equation for metric from coframe.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
transpose(lfg . fri) . fri,factor;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
This coframe gives the exterior Schwarzschild metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("This coframe gives the exterior Schwarzschild metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(true);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg:lg,rootscontract;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
christof(mcs);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find the 4 acceleration in the Hagihara free falling frame to get cc(r).
Start with orbiting observer in the coframe field.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find the 4 acceleration in the Hagihara free falling frame to get cc(r).
Start with orbiting observer in the coframe field.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uf[1]:c$uf[2]:0$uf[3]:0$uf[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uf);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iua:ua([-μ],[])=uf([],[λ])*covdiff(uf([],[μ]),λ)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cua:ic_convert(iua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cua,factor);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Hagihara coframe 4 acceleration in radial direction
is set to zero so it is free falling.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Hagihara coframe 4 acceleration in radial direction
is set to zero so it is free falling.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for i thru dim do ua[i]:ev(ua[i]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq5:num(ua[2])=0;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
factor(%);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
scc2:solve(eq5,cc^2)[1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("found the missing cc factor to make radial acceleration zero")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
scc1:sqrt(scc2),factor;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Substitute factors back in the Hagihara coframe for a solution.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Substitute factors back in the Hagihara coframe for a solution.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ratfact:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
mfri:zeromatrix(dim,dim)$mfri[1,1]:ev(rhs(saa1),scc1)$mfri[1,4]:-ev(rhs(sbb1),scc1)$
mfri[4,1]:-rhs(scc1)$mfri[2,2]:sqrt(lg[2,2])$mfri[3,3]:r$mfri[4,4]:ev(rhs(sdd1),scc1,factor)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri:lfg.mfri,radcan,ratsimp;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(true);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Found the free falling Schwarzschild vacuum Hagihara frame and Hagihara coframe field.
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Found the free falling Schwarzschild vacuum Hagihara frame and Hagihara coframe field.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fr:ratsimp(fr),factor;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Lowered local a index of mfri gives lfri = fri_a_μ.
is already lowered.
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Lowered local a index of mfri gives lfri = fri_a_μ.
is already lowered.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lfri:ratsimp(fri);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Lowering coordinate index of fr_a^μ gives lfr_a_μ and is the same as fri_a_μ
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Lowering coordinate index of fr_a^μ gives lfr_a_μ and is the same as fri_a_μ")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lfr:ratsimp(fr.lg);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
is(lfr=lfri);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
frii:copymatrix(fri)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Get metric from coframe
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Get metric from coframe")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lgg:transpose(lfg . fri) . fri,factor,ratsimp;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
It gives the original metric.  This is also from coframe.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("It gives the original metric.  This is also from coframe.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(true);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
christof(mcs);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find the 4 acceleration in the Hagihara coframe.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find the 4 acceleration in the Hagihara coframe.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uf[1]:c$uf[2]:0$uf[3]:0$uf[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uf);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iua:ua([-μ],[])=uf([],[λ])*covdiff(uf([],[μ]),λ)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cua:ic_convert(iua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Hagihara coframe 4 acceleration is zero so it is free falling on the orbit theta = π/2.
components
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Hagihara coframe 4 acceleration is zero so it is free falling on the orbit theta = π/2.
components")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Set theta = π/2 for equator orbit
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Set theta = π/2 for equator orbit")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for i thru dim do ua[i]:ev(ua[i],theta=π/2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Total acceleration is zero")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find the 4 velocity of Hagihara coframe in Schwarzschild coordinates.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find the 4 velocity of Hagihara coframe in Schwarzschild coordinates.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uf[1]:c$uf[2]:0$uf[3]:0$uf[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uf);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(u)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iu:u([],[λ])=uf([],[a])*frame([a],[λ])$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iu)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cu:ic_convert(iu);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cu,frame=fr);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for i thru dim do u[i]:ev(ratsimp(u[i]),rootscontract);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(u);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Hagihara coframe 4 velocity components in Schwarzschild coordinates
on orbit theta = π/2.  Stable circular orbit is only r > 6*m.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Hagihara coframe 4 velocity components in Schwarzschild coordinates
on orbit theta = π/2.  Stable circular orbit is only r > 6*m.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
u[4]:u[4],rootscontract,theta=π/2;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sqrt(ev(u[4]*u[4]*lg[4,4],theta=π/2));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(u);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(um);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ium:um([],[])=u([],[a])*u([],[b])*g([a,b],[])$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(ium)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cum:ic_convert(ium);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Total frame 4 velocity squared  u^2 is -c^2=-1
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
ev(cum,factor);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(%,theta=π/2,factor);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
The energy E = -m*g[1,1]*U[1]=P_1 and
angular momentum L = m*g[4,4]*U[4]=P_4.
3rd invariant is ε=line element(τ).
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("The energy E = -m*g[1,1]*U[1]=P_1 and
angular momentum L = m*g[4,4]*U[4]=P_4.
3rd invariant is ε=line element(τ).")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
energy:E=-m*lg[1,1]*'diff(ct_coords[1],tau)^1;
dtdτ:solve(energy,'diff(t,tau)^1)[1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
angularm:m*lg[4,4]*'diff(ct_coords[4],tau)^1=L;
ev(angularm,theta=π/2);
dφpτ:(subst([theta=π/2],solve(angularm,'diff(ct_coords[4],tau)^1)[1]));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Calculate the -invariant line element
and solve for Energy/2.
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Calculate the -invariant line element
and solve for Energy/2.    ")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
inv:-ε=lg[1,1]*'diff(ct_coords[1],tau)^2+lg[4,4]*'diff(ct_coords[4],tau)^2+lg[2,2]*'diff(ct_coords[2],tau)^2
+lg[3,3]*'diff(ct_coords[3],tau)^2;
inv:ev(inv,theta=π/2,'diff(theta,tau)=0);
inv:ev(inv,theta=π/2,dtdτ,dφpτ,factor,'diff(r,tau)=0,'diff(theta,tau)=0);
inv:ev(solve(inv,E^2)[1]/2,expand);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Effective potential.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Effective potential.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
veff:rhs(inv);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
func(ε,L,c,m,r):=''veff;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("find the minimum of the potential as a function of r")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
func(1,L,1,m,r);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
diff(%,r);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
solve(%,r);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rmim:%[2];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
subst([L=sqrt(12*m^4)],%);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
When L = sqrt(12*m^4) the minimum stable orbit 
radius is 6*m.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("When L = sqrt(12*m^4) the minimum stable orbit 
radius is 6*m.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
func(1,sqrt(12*m^4),1,m,r);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
minvariation:diff(%,r)=0;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Solved for minimum stable orbit
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Solved for minimum stable orbit")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
float(solve(minvariation,r)[1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Plot the types of orbits possible because of potential.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Plot the types of orbits possible because of potential.
minimumis at L= sqrt(12) about 3.464 ")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
float(sqrt(12));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
wxplot2d([func(1,3.35,1,1,r),func(1,sqrt(12),1,1,r),func(1,3.6,1,1,r),func(1,sqrt(12),1,1,6)],[r,3.5,10],[grid2d,true]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Components of 4 velocity squared is -c^2
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Components of 4 velocity squared is -c^2")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(u);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ums2[1]:sqrt(u[1]*u[1]*-lg[1,1]);ums2[4]:sqrt(u[4]*u[4]*lg[4,4]),theta=π/2;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
-ums2[1]^2+ums2[4]^2,theta=π/2,factor;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
omega:ums2[4];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Frame speed in orbit at r=6*m")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
vv:ratsimp(ums2[4]/ums2[1])$
ev(vv*c,r=6*m);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
vvm:rootscontract(subst([r=rm*m],vv));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
wxplot2d([vvm],[rm,2.9,10],[grid2d,true],[xlabel,"r=r*m"],[ylabel,"C"],[title,"Speed in orbit as ratio of C"]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
The energy is P_1 * dt/dτ.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("The energy is P_1 * dt/dτ.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
depends(r,t);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
energy:E=-m*lg[1,1]*'diff(t,tau);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
The angluar momentum is P_4*dφ/dτ.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("The angluar momentum is P_4*dφ/dτ.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
angularm:L=m*lg[4,4]*'diff(phi,tau);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Hagihara coframe 4 velocity, dφ/dτ*dτ/dt component magnitude by
using Schwarzschild coordinate metric for scale.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Hagihara coframe 4 velocity, dφ/dτ * dτ/dt component magnitude by
using Schwarzschild coordinate metric for scale.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
assume(phi_t>0);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
assume(v>0)$facts(v);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
c*sqrt(u[4]^2*lg[4,4]/(u[1])^2/-lg[1,1]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
omega:ev(%,theta=π/2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
The omega_t at radius r
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("The omega_t at radius r")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
phi_t=omega;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
rfv:solve(%,r)[1];
/* [wxMaxima: input   end   ] */
/* [wxMaxima: question  start ] */
<math><st>Is </st><g>omega</g><st> positive or negative?</st></math>
/* [wxMaxima: question  end   ] */
/* [wxMaxima: answer  start ] */
positive;
/* [wxMaxima: answer  end   ] */
/* [wxMaxima: question  start ] */
<math><st>Is </st><munder altCopy="phi_t"><mrow><g>phi</g></mrow><mrow><mi>t</mi></mrow></munder><st> positive or negative?</st></math>
/* [wxMaxima: question  end   ] */
/* [wxMaxima: answer  start ] */
positive;
/* [wxMaxima: answer  end   ] */
/* [wxMaxima: question  start ] */
<math><st>Is </st><munder altCopy="omega_t"><mrow><g>omega</g></mrow><mrow><mi>t</mi></mrow></munder><st> positive or negative?</st></math>
/* [wxMaxima: question  end   ] */
/* [wxMaxima: answer  start ] */
positive;
/* [wxMaxima: answer  end   ] */


/* [wxMaxima: input   start ] */
cframe_flag:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(false);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ug:ug,ratsimp;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cgeodesic(false)$for ii thru dim do block([theta:π/2,r:6*m],geod[ii]:ev(geod[ii],diff,ratsimp));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for ii thru dim do ldisplay(geod[ii]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cframe_flag:true;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Find Gullstrand–Painlevé Coordinate Chart.
   [wxMaxima: section end   ] */


/* [wxMaxima: subsect start ]
Start with exterior Schwarzschild Metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find Gullstrand–Painlevé Coordinate Chart.
   Start with exterior Schwarzschild Metric. ")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find Gullstrand–Painlevé coordinates where time coordinate follows
proper time and spatial slices are flat.  Time component of 4 velocity will be 1.
Find function aaa(r) that is t= tr -aaa(r).
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find Gullstrand–Painlevé coordinates where time coordinate follows
proper time and spatial slices are flat.  Time component of 4 velocity will be 1.
Find function aaa(r) that is t= tr -aaa(r).")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
depends(aaa,r);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
list:[tr-aaa,r,theta,phi,[tr,r,theta,phi]];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Transform the Schwarzschild metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("New coordinates tranform Schwarzschild metric")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lgg:ctransformlist(lg,list);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Pick aaa(r) so lg[2,2]=1 this will make spatial slices flat.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Pick aaa(r) so lg[2,2]=1 this will make spatial slices flat.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq1:lgg[2,2]=1;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq1:solve(eq1,diff(aaa,r)^2)[1],factor;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq1:sqrt(eq1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
eq2:aaa='integrate(rhs(eq1),r),rootscontract;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Transform equations for Gullstrand–Painlevé Coordinates from Schwarzschild
Coordinates
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Transform equations for Gullstrand–Painlevé Coordinates from Schwarzschild
Coordinates")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
list:[tr-rhs(eq2),r,theta,phi,[tr,r,theta,phi]];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Transform the Exterior Schwarzschild metric to Gullstrand–Painlevé metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Transform the Exterior Schwarzschild metric to Gullstrand–Painlevé metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg:ctransformlist(lg,list),rootscontract;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Transform the Hagihara coframe of the Schwarzschild metric.
This is the new Hagihara coframe of the Gullstrand–Painlevé metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Transform the Hagihara coframe of the Schwarzschild metric.
This is the new Hagihara coframe of the Gullstrand–Painlevé metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fri:ctransformfrilist(fri,list);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Save old coordinates and update the new coordinates symbols
of Gullstrand–Painlevé metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Save old coordinates and update the new coordinates symbols
of Gullstrand–Painlevé metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
old_ct_coords:ct_coords;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ct_coords:list[dim+1];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Show what the ctransformfrilist function does.
Transform matrix for rank 2 tetrade field tensor.
This only transforms the coordinate index.  The local index of field
is flat and has no transformation. Show the tetrade transform matrix.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: subsect start ]
This transform does not replace coordinate symbols if changed.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Show what the ctransformfrilist function does.
Transform matrix for rank 2 tetrade field tensor.
This only transforms the coordinate index.  The local index of field
is flat and has no transformation. Show the tetrade transform matrix.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("This transform does not replace coordinate symbols if changed.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
trm:zeromatrix(dim,dim)$for i thru dim do for j thru dim do
trm[i,j]:diff(list[i],list[5][j]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("This transformation matrix base on the orginal fri and the new coords list.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
trm:trm,rootscontract;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
New Hagihara coframe does give Gullstrand–Painlevé metric as below.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("New Hagihara coframe does give Gullstrand–Painlevé metric as below.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
transpose(ufg.fri).fri,ratsimp,rootscontract;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find velocity of frame fr being Hagihara coframe of Gullstrand–Painlevé metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find velocity of frame fr being Hagihara coframe of Gullstrand–Painlevé metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fr:transpose((ufg.fri)^^-1)$
fr:ratsimp(fr),factor,rootscontract;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Cmetric gives the frame fr, lg, and ug.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Cmetric gives the frame fr, lg, and ug.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(true);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
The frame needs to be simplified
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("The frame needs to be simplified")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
fr:ratsimp(fr),expand;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
This is the Christoffel symbols based on the new fri tetrade field
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("This is the Christoffel symbols based on the new fri tetrade field")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
christof(mcs);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Start with frame 4 velocity of a fixed observer in the frame.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Start with frame 4 velocity of a fixed observer in the frame.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uv1[1]:c$uv1[2]:0$uv1[3]:0$uv1[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uv1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ufv)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iufv:ufv([-μ],[])=uv1([],[a])*frame([a],[μ])$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iufv)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cufv:ic_convert(iufv);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cufv,frame:fr);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Hagihara frame 4 velocity in Gullstrand–Painlevé
coordinates has no e_r component and only 
a φ spatial component.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Hagihara frame 4 velocity in Gullstrand–Painlevé
coordinates has no e_r component and only 
a φ spatial component.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ufv[1]:ufv[1],rootscontract$ufv[4]:ufv[4],theta=π/2,rootscontract$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ufv);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Minium light orbit is where the speed in θ direction is 
near c for the frame.  But frame speed component in
Gullstrand–Painlevé coordinates is infinite and  time is also infinite.
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
("Minium light orbit is where the speed in θ direction is 
near c for the frame.  But frame speed component in
Gullstrand–Painlevé coordinates is infinite and  time is also infinite.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sum(ufv[aa]*ufv[4]*lg[aa,4],aa,1,4);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ufv[4]*ufv[4]*lg[4,4];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
%,theta=π/2,c=1;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ps:float(solve(%=10^15,r));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
This speed is big at the radius 3 m and rs = 2 m.
So photo-sphere is at r = 1.5 rs.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("This speed is big at the radius 3 m and rs = 2 m.
So photo-sphere is at r = 1.5 rs.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
subst([m=rs/2],ps);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ufvm:matrix([ufv[1],0,0,ufv[4]]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Calculate magnitude of ufvm")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ufvm.transpose(ufvm.lg);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
factor(%);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
subst([r=4*m,theta=π/2],%);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Find the 4 acceleration in this frame using coordinate Christoffel symbols.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Find the 4 acceleration in this frame using coordinate Christoffel symbols.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
uf[1]:c$uf[2]:0$uf[3]:0$uf[4]:0$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(uf);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
kill(ua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
iua:ua([-μ],[])=uf([],[λ])*covdiff(uf([],[μ]),λ)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ishow(iua)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cua:ic_convert(iua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(cua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Hagihara frame in Gullstrand–Painlevé coordinate  4 acceleration
Components are the effective gravity for Hagihara observer.
It is zero when theta = π/2, which is an orbit at the equator.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Hagihara frame in Gullstrand–Painlevé coordinate  4 acceleration
Components are the effective gravity for Hagihara observer.
It is zero when theta = π/2, which is an orbit at the equator.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
listarray(ua);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Frame metric is lfg
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Frame metric is lfg gives zero acceleration
and θ = π/2")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ua[3]*ua[3]*lfg[3,3],theta=π/2;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Magnitude of 4 acceleration needed d^2φ/dτ^2 as function of r
This is the same acceleration at theta= 2*π that the orbit coframe for 
Gullstrand–Painlevé metric.
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
("Magnitude of 4 acceleration needed d^2φ/dτ^2 as function of r
This is the same acceleration at theta= 2*π that the orbit coframe for 
Gullstrand–Painlevé metric.")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(sqrt(ua[3]),rootscontract);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ev(%,theta=π/2);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cframe_flag:false;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cmetric(false);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
ug:ug,ratsimp;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
lg;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cgeodesic(false)$for ii thru dim do block([theta:π/2,r:6*m],geod[ii]:ev(geod[ii],diff,ratsimp));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("Geodesic in the Gullstrand–Painlevé coordinate")$;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
for ii thru dim do ldisplay(geod[ii]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cframe_flag:true;
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
("End")$;
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 26.01.0-DevelopmentSnapshot"$
